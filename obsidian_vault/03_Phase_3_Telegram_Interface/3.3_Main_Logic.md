# 3.3 Main Logic - Wire the Capture System End-to-End
Status: - [x] Completed

## Description
Wire everything together: text/voice → Claude Parser → Google Calendar, plus chore commands. This is where the Capture System becomes real — messages go in, calendar events come out.

## Files to Create/Edit
- [ ] `src/bot/telegram_bot.py` (update existing)
- [ ] `main.py` (new - project entry point)

## Prompt for Claude
```
You are building **LifeOS Assistant**. This task wires the **Capture System end-to-end**: user sends a message (text or voice) → Claude parses it into a `ParsedEvent` → event is written to Google Calendar → user gets a confirmation. This is also where chore commands get connected.

The following modules exist:
- `src/bot/telegram_bot.py`: Telegram bot with text, voice, and command handlers.
- `src/core/parser.py`: `parse_message(text) -> ParsedEvent | None`
- `src/core/transcriber.py`: `transcribe_audio(file_path) -> str`
- `src/integrations/gcal_service.py`: `add_event(parsed_event) -> dict`, `get_daily_events(date) -> list[dict]`
- `src/data/db.py`: `ChoreDB` class with `add_chore()`, `get_due_chores()`, `list_all()`, `mark_done()`

The **ParsedEvent JSON contract** (defined in `1.2`, consumed here):
```json
{
  "event": "Dentist appointment",
  "date": "2025-02-14",
  "time": "16:00",
  "duration_minutes": 60,
  "description": ""
}
```

Perform the following:

1. Update `src/bot/telegram_bot.py`:
   - **Text message handler** (replace the echo handler):
     a. Send a "Processing..." message to indicate the bot is working.
     b. Call `parse_message(user_text)` to extract event data.
     c. If a ParsedEvent is returned:
        - Call `add_event(parsed_event)` to create the calendar event.
        - Send a confirmation: "✅ Event created: {event name} on {date} at {time}" with the Google Calendar link.
     d. If no event is found:
        - Send: "I couldn't find any event details in your message. Try something like: 'Meeting with Dan tomorrow at 14:00'"
     e. Handle errors gracefully and inform the user.

   - **Voice message handler** (update existing):
     a. After transcription, run the same parse → calendar flow as text.
     b. Show the user what was transcribed before processing.

   - **`/today` command** (replace placeholder):
     a. Call `get_daily_events()`.
     b. Format events as a readable list and send to the user.

   - **`/addchore` command** (replace placeholder):
     a. Prompt the user for chore details (name, frequency in days, assigned to).
     b. Use a ConversationHandler or sequential prompts to collect the data.
     c. Call `ChoreDB().add_chore(name, frequency_days, assigned_to)`.
     d. Confirm: "✅ Chore added: {name} (every {frequency} days, assigned to {person})"

   - **`/chores` command** (replace placeholder):
     a. Call `ChoreDB().list_all()`.
     b. Display all active chores with their ID, name, next_due date, and assigned_to.

   - **`/done <id>` command** (replace placeholder):
     a. Parse the chore ID from the command argument.
     b. Call `ChoreDB().mark_done(chore_id)`.
     c. Confirm: "✅ Marked '{chore_name}' as done. Next due: {next_due}"

2. Create `main.py` in the project root:
   - Import and call `main()` from `src/bot/telegram_bot.py`.
   - Set up logging configuration (level=INFO, format with timestamp).
   - This is the single entry point: `python main.py` starts the bot.

3. All user-facing messages should be clean and friendly. Handle all errors with user-friendly messages (don't expose tracebacks to the user).

Do NOT break existing functionality. Build on top of what exists.
```

## Implementation Logs
- **Commit:** `7764a87` — feat(telegram): 3.3 Main Logic
- **Files updated:**
  - `src/bot/telegram_bot.py` — Full wiring: text→parser→calendar, voice→whisper→parser→calendar, /today, /addchore (ConversationHandler), /chores, /done
- **Files created:**
  - `main.py` — Single entry point with logging config
